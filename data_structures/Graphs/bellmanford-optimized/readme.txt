"The Bellman–Ford algorithm is an algorithm that computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph.[1] It is slower than Dijkstra's algorithm for the same problem, but more versatile, as it is capable of handling graphs in which some of the edge weights are negative numbers. The algorithm was first proposed by Alfonso Shimbel (1955), but is instead named after Richard Bellman and Lester Ford Jr., who published it in 1958 and 1956, respectively.[2] Edward F. Moore also published a variation of the algorithm in 1959, and for this reason it is also sometimes called the Bellman–Ford–Moore algorithm.[1]

Negative edge weights are found in various applications of graphs, hence the usefulness of this algorithm.[3] If a graph contains a "negative cycle" (i.e. a cycle whose edges sum to a negative value) that is reachable from the source, then there is no cheapest path: any path that has a point on the negative cycle can be made cheaper by one more walk around the negative cycle. In such a case, the Bellman–Ford algorithm can detect and report the negative cycle" - Wikipedia.

In essence, Bellman-Ford algorithm is very similar to dijkstra, but instead of exploiting the current best solution, it tries to use each edge for the "relaxation" of the others, therefore it can detect a negative cicle (because we do not allow multiple edges between the same pair of nodes (A,B), so we can have at most (N-1)*M edges in a directed graph).

The code presented here is the optimisation of the canonical Bellman-Ford algorithm. It makes use of the fact that we only need to use nodes whose values have been updated, instead of trying to use all of them. Although the theoretical complexity is the same, in practice it even behaves better than Dijkstra with heaps and it is much easier to code.

ATTENTION! this version is for unoriented graphs, to change it for oriented graphs, one must only delete the symmetric insertion of edges in the "addToAdjacencyList" method.