Greedy Algorithm
탐욕스러운 알고리즘은 어떤 다음 단계가 가장 확실한 이익을 제공할 것인지를 결정함으로써 복잡하고 다단계 문제에 대한 간단하고 실행하기 쉬운 해결책을 찾는 수학 과정입니다.
이러한 알고리즘은 탐욕스럽다고 불리는데, 각각의 작은 인스턴스에 대한 최적의 해결책은 즉각적인 출력을 제공하지만 알고리즘은 더 큰 문제를 전체적으로 고려하지 않기 때문입니다. 일단 결정이 내려지면 그것은 결코 재고되지 않습니다.
탐욕스러운 알고리즘은 가능한 가장 작은 구성 요소에서 개체 집합을 재귀적으로 구성함으로써 작동합니다. 재귀는 특정 문제에 대한 해결책이 동일한 문제의 소규모 사례에 대한 해결책에 의존하는 문제해결에 대한 접근법입니다. 탐욕스러운 알고리즘을 사용하는 이점은 문제의 작은 예에 대한 해결책이 간단하고 이해하기 쉽다는 것입니다. 단점은 가장 최적의 단기 해결책이 최악의 장기적 결과로 이어질 수 있다는 점입니다.
홉 수가 가장 적고 가능한 가장 짧은 지연으로 패킷을 효율적으로 라우팅하기 위해 임시 모바일 네트워킹에서 탐욕스러운 알고리즘이 종종 사용됩니다. 머신러닝(machine learning), 비즈니스 인텔리전스(BI), 인공지능(AI), 프로그래밍에도 사용됩니다.
Job sequencing problem
문제
모든 작업에 마감일이 있고 마감일 전에 작업을 마칠 경우 관련 이익이 있는 일련의 작업을 지정합니다. 또한 모든 직업에는 시간 단위가 한 개씩 소요되기 때문에 어떤 직업이든 가능한 최소 마감일은 1입니다. 한 번에 하나의 작업만 예약할 수 있다면 총 수익을 극대화할 수 있는 방법을 구하십시오.
해결책
간단한 해결책은 주어진 일련의 모든 하위 집합을 생성하고 개별 하위 집합에서 해당 하위 집합의 작업 타당성을 확인하는 것입니다. 실현 가능한 모든 하위 집합에서 최대 이익을 추적하십시오. 이 솔루션의 시간 복잡성은 기하급수적입니다.
이것은 표준 탐욕 알고리즘 문제입니다. 알고리즘은 다음과 같습니다.
1.수익 감소 순서에 따라 모든 직업을 분류하십시오.
2.정렬된 작업의 첫 번째 작업으로 결과 시퀀스를 초기화하십시오.
3.나머지 n-1 작업에 대해 다음 작업 수행하십시오.
현재 작업이 마감일을 놓치지 않고 현재 결과 시퀀스에 적합할 수 있는 경우 결과에 현재 작업을 추가하십시오. 그렇지 않으면 현재 작업을 무시하십시오.

MinNoOfBrackets
문제
N '['괄호와 N '] ' 괄호로 구성된 2N 문자열이 주어집니다. 문자열은 S2[S1]에 표시할 수 있는 경우, S1과 S2가 균형 문자열인 경우 균형 조정으로 간주됩니다. 우리는 인접한 문자를 스와핑 하여 불균형한 문자열의 균형을 맞출 수 있습니다. 문자열을 밸런싱하는데 필요한 최소 스왑의 수를 계산하십시오.
해결책
우리는 처음에 줄을 통과해서 벡터 'pos'에 '['의 위치를 저장할 수 있습니다. 'p'를 0으로 초기화하십시오. 우리는 p를 사용하여 벡터 'pos'를 가로지를 것입니다. 순진한 접근법과 유사하게, 우리는 마주친 '[' 괄호 수를 유지합니다. 우리가 '['에 부딪히면 카운트를 늘리고, 'p'를 1씩 증가시킵니다. 우리는 ']'에 부딪히면 수를 줄입니다. 만약 카운트가 음수가 되면, 이것은 우리가 스와핑을 시작해야 한다는 것을 의미합니다. 원소 pos[p]는 다음 '['의 지수를 알려줍니다. 우리는 그 합을 포스[p] – i로 증가시킵니다. 여기서 ‘I’는 현재 지수입니다. 우리는 현재 지수 및 포지션의 요소와 리셋 카운트를 0으로 바꿀 수 있습니다.

간단한 접근방식에서 O(N)였던 단계를 O(1) 단계로 전환했기 때문에 우리의 새로운 시간 복잡성은 감소합니다. 시간 복잡도 = O(N) 추가 공간 = O(N)

Radix sort
비교 기반 정렬 알고리즘(Merge Sort, 힙 정렬, Quick-Sort...)은 Ω(nLogn), 즉 nLogn보다 잘 할 수 없습니다. 계수 정렬은 원소가 1에서 k까지의 범위에 있을 때 O(n+k) 시간으로 정렬하는 선형 시간 정렬 알고리즘입니다.
예시
정렬되지 않은 목록: 170, 45, 75, 90, 802, 24, 2, 66
최소 중요 자릿수(1초 단위)로 정렬한 목록: 170, 90, 802, 2, 24, 45, 75, 66

Activity Selection Problem
문제
N 활동 목록이 제공된다(각각 시작 시간(Si)과 종료 시간(Fi)). 출발 시간 Si, Sj, 결승 시간 Fi, Fj가 각각 있는 두 가지 활동은 Si > Fj 또는 Sj > Fi일 경우 상충되지 않는다고 합니다. 예약된 활동 간에 충돌이 없도록 스케쥴링할 수 있는 최대 활동 수를 찾으십시오.
입력 값
첫 번째 줄은 활동 횟수인 정수 N을 포함합니다. 다음 N 선은 각각 Si와 Fi 두 개의 정수를 포함합니다(활동의 시작 및 종료 시간 i).
출력 값
단일 정수(예약할 수 있는 최대 활동 수) 출력합니다.
설명
활동 세트를 S = {1, 2, 3, ...n}으로 하고 활동을 종료 시간별로 정렬합니다. 탐욕스러운 선택은 항상 활동 1을 선택하는 것입니다. 왜 활동 1은 항상 최적의 해결책 중 하나를 제공하는가에 대해서는 1번 외에 다른 1번 활동으로 B번 해결책이 있다면, 1번 활동으로 1번 활동과 같은 크기의 해결책도 있다는 것을 보여줌으로써 증명할 수 있습니다. B가 선택한 첫 번째 활동을 k로 하면 A = {B – {k} U{1}. (B의 활동은 독립적이며 k의 마무리 시간이 가장 짧다는 점에 유의하십시오. k가 1이 아니므로 finish(k) >= finish(1))

Dijkstra's Shortest Path Algorithm
네트워크에서 노드 사이의 최단 경로 찾기 초기 노드로 시작하고 각 단계를 통해 개선될 거리 값을 할당합니다. 먼저 거리 값(초기 노드의 경우 0, 다른 노드의 경우 무한)을 할당하고 방문하지 않은 노드 집합을 만드십시오. 현재 노드의 경우, 모든 인접 노드와 그 주변 노드의 잠정적 차이를 계산하고, 그 값을 할당된 값과 비교한 후 작은 값을 할당 받습니다. 현재 노드의 모든 인접 노드를 고려한 후 방문한 노드로 표시하고 방문하지 않은 세트에서 제거하십시오. 대상 노드가 방문한 것으로 표시되거나 방문하지 않은 집합의 노드 중 최소 임시 거리가 무한(초기 노드와 나머지 노드 간 연결 없음)인 경우 알고리즘을 중지하십시오. 그렇지 않으면 현재 노드를 최소의 임시 거리로 방문하지 않은 노드로 설정하고 반복하십시오.

Egyptian Fraction
Egyptian Fraction은 다음과 같이 구별되는 단위 분수의 유한한 합입니다.

1/2 + 1/3 + 1/16
즉, 표현에서 각 분수는 1과 같은 분자와 양의 정수인 분모를 가지며, 모든 분모는 서로 다릅니다. 이러한 유형의 표현 값은 양수 a/b입니다. 예를 들어 위의 이집트 분수는 43/48에 이릅니다. 모든 양의 이성적인 숫자는 이집트 분수로 표현될 수 있습니다.
Egyptian Fraction 표현 2/3= 1/2 + 1/6 
Egyptian Fraction 표현 6/14= 1/3 + 1/11 + 1/231 
Egyptian Fraction 표현 12/13= 1/2 + 1/3 + 1/12 + 1/156
우리는 탐욕 알고리즘을 사용하여 Egyptian Fraction을 생성할 수 있습니다.

Fractional knapsack
n개 항목의 무게와 값을 고려할 때, 우리는 이 항목들을 용량 W의 knapsack에 넣어 knapsack의 최대 총 값을 얻을 필요가 있습니다. 0-1 knapsack 문제에서 우리는 아이템을 깨는 것이 허용되지 않습니다. 우리는 전체 아이템을 가져가거나 받지 않습니다. Fractional knapsack에서는 knapsack의 총가치를 극대화하기 위한 아이템을 깰 수 있습니다.

Huffman coding
Huffman Coding은 무손실 데이터 압축 알고리즘입니다. 그 아이디어는 입력 문자에 가변 길이 코드를 할당하는 것입니다. 할당된 코드의 길이는 해당 문자의 빈도에 기초합니다. 가장 빈도가 높은 문자는 가장 작은 코드를, 가장 빈도가 낮은 문자는 가장 큰 코드를 갖습니다. 입력 문자에 할당된 가변 길이 코드는 접두사 코드, 즉 한 문자에 할당된 코드가 다른 문자에 할당된 코드의 접두사가 아닌 방식으로 코드(비트 시퀀스)가 할당되는 것을 의미합니다. Huffman Coding은 생성된 비트 스트림을 디코딩할 때 모호함이 없도록 하는 방법입니다. a, b, c, d 4자가 되도록 하고, 해당 가변 길이 코드는 00, 01, 0, 1이 되도록 합니다. c에 할당된 코드는 a와 b에 할당된 코드의 접두사이기 때문에 이 코딩은 모호성으로 이어집니다. 압축 비트 스트림이 0001인 경우, 압축 해제된 출력은 "ccd" 또는 "ccb" 또는 "acd" 또는 "ab"이 될 수 있습니다.

Knapsack Problem
문제
도둑이 상점을 털고 있고, 그의 배낭에 W의 최대 무게를 실을 수 있습니다. 매장에서 구할 수 있는 아이템은 n개, it 아이템 무게는 wi, 이익은 pi입니다. 도둑은 어떤 물건을 가져가야 하는가에 대한 문제입니다.

이런 맥락에서, 그 아이템들은 도둑이 최대한 이익을 얻을 수 있는 아이템들을 가지고 다닐 수 있도록 선택되어야 합니다. 따라서, 도둑의 목적은 이익을 최대화하는 것입니다.
알고리즘
배낭이 무게 W를 가지고 있고 아이템이 값 vi와 무게 wi를 가지고 있다고 가정합시다. vi/wi 비율에 따라 아이템 순위를 매깁니다:
vi / wi, 모든 i ≤ vj / wj, 모든 아이템에 대해 vi / wj를 고려하십시오. 비율 감소의 순서로 각 아이템을 최대한 많이 가져갑니다.

Kruskal’s algorithm
연결된 그래프와 리디렉션되지 않은 그래프를 볼 때, 그 그래프의 스패닝 트리는 하나의 하위 그래프로서 모든 정점을 서로 연결합니다. 단일 그래프에는 많은 다른 스패닝 트리가 있을 수 있습니다. 가중, 연결 및 리디렉션 되지 않은 그래프를 위한 최소 스패닝 트리(MST) 또는 최소 스패닝 트리(Spanning Tree)는 모든 스패닝 트리의 무게보다 작거나 같은 중량을 갖는 스패닝 트리입니다. 스패닝 트리의 무게는 스패닝 트리의 각 가장자리에 주어진 무게의 합입니다.
크루스칼의 알고리즘은 숲에 있는 어떤 두 나무라도 연결하는 가능한 최소 무게의 가장자리를 찾는 최소 스패닝 트리 알고리즘입니다. [1] 연결된 가중 그래프의 최소 스패닝 트리를 찾아 각 단계에서 증가하는 비용 호를 추가하므로 그래프 이론에서 탐욕스러운 알고리즘입니다. [1] 이는 모든 꼭지점을 포함하는 트리를 형성하는 가장자리의 부분 집합을 찾는다는 것을 의미하며, 여기서 트리의 모든 가장자리의 총 중량은 최소화됩니다. 그래프가 연결되지 않은 경우 최소 스패닝 포리스트(연결된 각 구성 요소에 대한 최소 스패닝 트리)를 찾습니다.

Minimum coins
잔돈 문제는 주어진 금액에 해당하는 (특정 화폐의) 최소 화폐 수를 찾는 문제를 다룹니다. 정수 배낭 문제의 특수한 경우로, 단순한 통화 이상의 응용 범위를 가지고 있습니다.
그것은 또한 동전 교환 문제의 가장 일반적인 변화로, 무한히 많은 동전 세트의 사용 가능한 액면들을 고려해 볼 때, 동전의 순서를 고려하지 않고 특정한 금액으로 변화를 만드는 가능한 방법의 수를 알아내는 것이 목표인 칸막이의 일반적인 경우입니다.
약하게 NP-hard이지만 동적 프로그래밍에 의해 최적으로 해결될 수도 있습니다.

Prim’s algorithm
연결된 그래프와 리디렉션되지 않은 그래프를 볼 때, 그 그래프의 스패닝 트리는 하나의 하위 그래프로서 모든 정점을 서로 연결합니다. 단일 그래프에는 많은 다른 스패닝 트리가 있을 수 있습니다. 가중, 연결 및 리디렉션되지 않은 그래프를 위한 최소 스패닝 트리(MST) 또는 최소 스패닝 트리(Spanning Tree)는 모든 스패닝 트리의 무게보다 작거나 같은 중량을 갖는 스패닝 트리입니다. 스패닝 트리의 무게는 스패닝 트리의 각 가장자리에 주어진 무게의 합입니다.

Prim의 알고리즘은 가중치 미방향 그래프를 위한 최소 스패닝 트리를 찾는 탐욕스러운 알고리즘입니다. 즉, 모든 정점을 포함하는 트리를 형성하는 가장자리의 부분 집합을 찾으며, 트리 내 모든 가장자리의 총 중량은 최소화됩니다. 알고리즘은 임의의 시작 꼭지점에서부터 이 트리를 한 번에 한 꼭지점으로 만들어 각 단계에서 트리에서 다른 꼭지점으로 가장 저렴한 연결을 추가함으로써 작동합니다.

Sum areas rectangle
배열이 주어진 과제는 배열 요소에서 형성될 수 있는 모든 가능한 최대 면적 직사각형의 합계를 계산하는 것입니다. 또한 배열의 요소를 최대 1까지 줄일 수 있습니다.
간단한 접근법
가능한 배열의 네 가지 요소를 모두 확인한 다음 직사각형을 형성할 수 있는 요소를 확인하십시오. 이 직사각형에서는 이러한 원소에 의해 형성되는 최대 면적의 직사각형을 모두 분리합니다. 직사각형 및 직사각형 영역을 구한 후 모두 합쳐서 원하는 솔루션을 얻으십시오.
효율적 접근법
최대 면적 사각형을 얻으려면 먼저 배열 요소를 증가하지 않는 배열로 정렬하십시오. 정렬 후 절차를 시작하여 배열의 요소를 선택하십시오. 여기서 배열의 원소가 같거나(a[i] == a[i+1]) 작은 원소의 길이가 a[i]보다 1 작은 경우(이 경우 a[i]가 1씩 줄어들기 때문에 길이 a[i+1]가 됩니다). 길이와 너비를 모두 갖췄는지 확인하기 위해 한 가지 국기 변수가 유지됩니다. 길이를 구한 후 플래그 변수를 설정하고, 이제 길이와 같은 방법으로 너비를 계산하여 직사각형의 면적을 합합니다. 길이와 너비를 모두 얻은 후 다시 플래그 변수를 false로 설정하여 새로운 직사각형을 검색해 보십시오. 이 과정이 반복되고 마지막으로 면적의 최종 합이 반환됩니다.
